<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>
    <title>Pose to Code</title>
    <link rel="stylesheet" href="styles.css">
    <script src="https://preview.babylonjs.com/babylon.js"></script>
    <script src="https://preview.babylonjs.com/loaders/babylonjs.loaders.min.js"></script>
    <script src="https://preview.babylonjs.com/gui/babylon.gui.min.js"></script>
    <script src="https://code.jquery.com/pep/0.4.3/pep.js"></script>
    <script src="blockly/blockly_compressed.js"></script>
    <script src="blockly/javascript_compressed.js"></script>
    <script src="blockly/blocks_compressed.js"></script>
    <script src="blockly/msg/js/en.js"></script>
    <script src="code_blocks.js"></script>
    <!-- mediapipe imports -->
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/control_utils/control_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/drawing_utils/drawing_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/pose/pose.js" crossorigin="anonymous"></script>
  </head>
  <body>
    <div id="levelUpModal" class="modal">
      <!-- Modal content -->
      <div class="modal-content">
        <span class="close">&times;</span>
        <p id="inject-text">Some text</p>
      </div>
    </div>
    <div id="blocklyDiv">
        <button id="run" onclick="runCode()">Run!</button>
    </div>
    <div class="poseDiv">
			<video class="input_video" hidden></video>
			<canvas class="output_canvas"></canvas>
		</div>
    <canvas id="renderCanvas" touch-action="none"></canvas>
    <xml xmlns="https://developers.google.com/blockly/xml" id="toolbox" style="display: none">
      <sep></sep>
      <!--<category name="Click for Actions">
          <block type="create_sphere">
          <field name="NAME">small</field>
          </block>
          <block type="place"></block>
          <block type="dance"></block>
      </category>
      <category name="Loops">
          <block type="controls_repeat_ext"></block>
      </category>
      <category name="Math">
          <block type="math_number"></block>
      </category>-->
    </xml>
    <xml xmlns="https://developers.google.com/blockly/xml" id="workspaceBlocks" style="display: none"></xml>
    <script>
      var toolbox = document.getElementById("toolbox");
      var options = { 
          toolbox : toolbox, 
          collapse : true, 
          comments : false, 
          disable : true, 
          maxBlocks : Infinity, 
          trashcan : true, 
          horizontalLayout : false, 
          toolboxPosition : 'start', 
          css : true, 
          media : 'https://blockly-demo.appspot.com/static/media/', 
          rtl : false, 
          scrollbars : true, 
          sounds : true, 
          oneBasedIndex : true
      };
      /* Inject your Blockly workspace */ 
      var blocklyDiv =  document.getElementById('blocklyDiv');
      var workspace = Blockly.inject(blocklyDiv, options);
      var workspaceBlocks = document.getElementById("workspaceBlocks"); 
      Blockly.Xml.domToWorkspace(workspaceBlocks, workspace);
      /* variables to hold current parent block and child block */
      var parentBlock = null;
      var childBlock = null;
      /* keep track of all blocks for resetting */
      var allBlocks = [];

      var sphereSizeFlag = false;
      var startMotion = 0;
      var standingDistLeft = 0;
      var standingDistRight = 0;

      const videoElement = document.getElementsByClassName('input_video')[0];
      const canvasElement = document.getElementsByClassName('output_canvas')[0];
      const canvasCtx = canvasElement.getContext('2d');

      function onResults(results) {
        canvasCtx.save();
        canvasCtx.clearRect(0, 0, canvasElement.width, canvasElement.height);
        canvasCtx.drawImage(
            results.image, 0, 0, canvasElement.width, canvasElement.height);
        drawConnectors(canvasCtx, results.poseLandmarks, POSE_CONNECTIONS,
                        {color: '#00FF00', lineWidth: 4});
        drawLandmarks(canvasCtx, results.poseLandmarks,
                        {color: '#FF0000', lineWidth: 2});

        if(startMotion <= 100){
          standingDistLeft = results.poseLandmarks[28].y - results.poseLandmarks[24].y;
          standingDistRight = results.poseLandmarks[27].y - results.poseLandmarks[23].y;
          startMotion += 1;
        }
        //dance (both arms out to the side)
        var leftDist = Math.abs(results.poseLandmarks[14].y - results.poseLandmarks[12].y)
        var rightDist = Math.abs(results.poseLandmarks[11].y - results.poseLandmarks[13].y)
        if(rightDist < 0.01 && leftDist < 0.01) {
          setTimeout(() => {    
            console.log("dance");
            /* programatically adding code block */
            if(parentBlock == null) {
              parentBlock = workspace.newBlock('dance');
              parentBlock.initSvg();
              parentBlock.render();
            } 
            else {
              childBlock = workspace.newBlock('dance');
              childBlock.initSvg();
              childBlock.render();
              var parentConnection = parentBlock.nextConnection;
              var childConnection = childBlock.previousConnection;
              parentConnection.connect(childConnection);
              parentBlock = childBlock;
            }
            allBlocks.push(parentBlock);
          }, 600);
          canvasCtx.restore();
        }
        //run (paused running motion --> left hand up + right hand down)
        else if(results.poseLandmarks[20].y < results.poseLandmarks[5].y && !(results.poseLandmarks[19].y < results.poseLandmarks[2].y)) {
          setTimeout(() => {     
            console.log("run");
          }, 600);
          canvasCtx.restore();
        }
        //reset (both hands above head)
        else if(results.poseLandmarks[21].y < results.poseLandmarks[2].y && results.poseLandmarks[22].y < results.poseLandmarks[2].y) {
          setTimeout(() => {     
            console.log("reset");
            //delete all code blocks in the workspace
            for(i = 0; i < allBlocks.length; i++) {
              allBlocks[i].dispose(true);
            }
            // TODO: move robot position back to y=0
            // robot.position.y = 0;
          }, 600);
          canvasCtx.restore();
        }
        //make sphere (hands in front of chest)
        else if((results.poseLandmarks[20].x > results.poseLandmarks[12].x) && (results.poseLandmarks[19].x < results.poseLandmarks[11].x) && (results.poseLandmarks[20].y < results.poseLandmarks[14].y && results.poseLandmarks[20].y > results.poseLandmarks[12].y) && (results.poseLandmarks[19].y < results.poseLandmarks[13].y && results.poseLandmarks[19].y > results.poseLandmarks[11].y)) {
          setTimeout(() => {     
            console.log("create sphere");
            /* add code block */
            if(parentBlock == null) {
              parentBlock = workspace.newBlock('create_sphere');
              parentBlock.initSvg();
              parentBlock.render();
            } 
            else {
              childBlock = workspace.newBlock('create_sphere');
              childBlock.initSvg();
              childBlock.render();
              var parentConnection = parentBlock.nextConnection;
              var childConnection = childBlock.previousConnection;
              parentConnection.connect(childConnection);
              parentBlock = childBlock;
            }
            allBlocks.push(parentBlock);
          }, 600);
          sphereSizeFlag = true;
          canvasCtx.restore();
        }
        //size of sphere (right arm: low)
        else if(results.poseLandmarks[19].y > results.poseLandmarks[23].y && sphereSizeFlag) {
          setTimeout(() => {     
            console.log("small sphere");
            //change field value of create_sphere block
            if(parentBlock != null) {
              childBlock = workspace.newBlock('size');
              childBlock.setFieldValue('small', 'TEXT');
              var parentConnection = parentBlock.getInput('TEXT').connection;
              var childConnection = childBlock.outputConnection;
              parentConnection.connect(childConnection);
            }
          }, 600);
          sphereSizeFlag = false;
          canvasCtx.restore();
        }
        //size of sphere (right arm: med)
        else if(results.poseLandmarks[19].y < results.poseLandmarks[23].y && results.poseLandmarks[19].y > results.poseLandmarks[11].y && sphereSizeFlag) {
          setTimeout(() => {     
            console.log("med sphere");
            //change field value of create_sphere block
            if(parentBlock != null) {
              childBlock = workspace.newBlock('size');
              childBlock.setFieldValue('medium', 'TEXT');
              var parentConnection = parentBlock.getInput('TEXT').connection;
              var childConnection = childBlock.outputConnection;
              parentConnection.connect(childConnection);
            }
          }, 600);
          sphereSizeFlag = false;
          canvasCtx.restore();
        }
        //size of sphere (right arm: high)
        else if(results.poseLandmarks[19].y < results.poseLandmarks[11].y && sphereSizeFlag) {
          setTimeout(() => {     
            console.log("large sphere");
            //change field value of create_sphere block
            if(parentBlock != null) {
              childBlock = workspace.newBlock('size');
              childBlock.setFieldValue('large', 'TEXT');
              var parentConnection = parentBlock.getInput('TEXT').connection;
              var childConnection = childBlock.outputConnection;
              parentConnection.connect(childConnection);
            }
          }, 600);
          sphereSizeFlag = false;
          canvasCtx.restore();
        }
        //place sphere (squat)
        //else if(results.poseLandmarks[28].y - results.poseLandmarks[24].y < standingDistLeft && results.poseLandmarks[27].y - results.poseLandmarks[23].y < standingDistRight) {
            //setTimeout(() => {     
            //console.log("place sphere")
            //}, 600);
            //sphereSizeFlag = false;
            //canvasCtx.restore();
        //}
      }
      const pose = new Pose({locateFile: (file) => {
        return `https://cdn.jsdelivr.net/npm/@mediapipe/pose/${file}`;
      }});
      pose.setOptions({
        selfieMode: true,
        upperBodyOnly: false,
        smoothLandmarks: true,
        minDetectionConfidence: 0.5,
        minTrackingConfidence: 0.5
      });
      pose.onResults(onResults);

      const camera = new Camera(videoElement, {
        onFrame: async () => {
        await pose.send({image: videoElement});
      },
        width: 1280,
        height: 720
      });
      camera.start();
    </script>
    <script>
      function runCode() {
        window.LoopTrap = 1000;
        Blockly.JavaScript.INFINITE_LOOP_TRAP = 'if(--window.LoopTrap == 0) throw "Infinite loop.";\n';
        var code = Blockly.JavaScript.workspaceToCode(workspace);
        try {
            eval(code);
        } catch (e) {
            alert(e);
        }
        runOnGUI();
        setTimeout(function() { 
            document.activeElement.blur();
        }, 150);
      }
    </script>
    <script>
      var modal = document.getElementById("levelUpModal");
      var span = document.getElementsByClassName("close")[0];
      span.onclick = function() {
        modal.style.display = "none";
      }
      window.onclick = function(event) {
        if (event.target == modal) {
          modal.style.display = "none";
        }
      }
    </script>
    <script src="scene.js"></script>
  </body>
</html>